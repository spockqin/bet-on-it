{"version":3,"sources":["../src/events.js"],"names":["description","ipfs","addJSONAsync","publishEventDescription","ipfsHash","catJSONAsync","loadEventDescription","methodName","functionInputs","name","type","eventAddress","outcome","opts","txOpts","event","contracts","Event","at","CentralizedOracle","oracle","setOutcome","resolveEvent","createCategoricalEvent","self","callerContract","EventFactory","eventName","eventArgName","resultContract","CategoricalEvent","createScalarEvent","ScalarEvent","estimateGas","using","gasStats","averageGasUsed","Error"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AA4CA;;;;;;;;;;;;;;0EAaO,iBAAwCA,WAAxC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BACU,KAAKC,IAAL,CAAUC,YAAV,CAAuBF,WAAvB,CADV;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,K;;oBAAeG,uB;;;;;AAItB;;;;;;;;;;;;2EASO,kBAAqCC,QAArC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BACU,KAAKH,IAAL,CAAUI,YAAV,CAAuBD,QAAvB,CADV;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,K;;oBAAeE,oB;;;;;AAItB;;;;;;;;;;;;2EASO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,6CAEC,8BAAkB,2BAAlB,EAAyC;AACrCC,wCAAY,cADyB;AAErCC,4CAAgB,CACZ,EAAEC,MAAM,OAAR,EAAiBC,MAAM,SAAvB,EADY,EAEZ,EAAED,MAAM,SAAR,EAAmBC,MAAM,QAAzB,EAFY;AAFqB,yBAAzC,CAFD,6JACKC,YADL,4BACmBC,OADnB,4BAC6BC,IAD7B;AAUGC,8BAVH,GAUY,oBAAOD,IAAP,EAAa,CAAC,MAAD,EAAS,IAAT,EAAe,OAAf,EAAwB,KAAxB,EAA+B,UAA/B,CAAb,CAVZ;AAYGE,6BAZH,GAYW,KAAKC,SAAL,CAAeC,KAAf,CAAqBC,EAArB,CAAwBP,YAAxB,CAZX;AAAA,uCAaY,KAAKK,SAAL,CAAeG,iBAb3B;AAAA;AAAA,+BAasDJ,MAAMK,MAAN,CAAaN,MAAb,CAbtD;;AAAA;AAAA;AAaGM,8BAbH,gBAa6CF,EAb7C;AAAA;AAAA;AAAA,+BAc4BE,OAAOC,UAAP,CAAkBT,OAAlB,EAA2BE,MAA3B,CAd5B;;AAAA;AAAA;AAAA,wDAcgE,mBAdhE;AAAA;AAAA;AAAA,+BAe4BC,MAAMM,UAAN,CAAiBP,MAAjB,CAf5B;;AAAA;AAAA;AAAA,wDAesD,mBAftD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,K;;oBAAeQ,Y;;;;;AAlFtB;;;;AAEA;;;;;;;;;;;;AAYO,IAAMC,0DAAyB,6BAAiB,UAACC,IAAD;AAAA,WAAW;AAC9DC,wBAAgBD,KAAKR,SAAL,CAAeU,YAD+B;AAE9DnB,oBAAY,wBAFkD;AAG9DoB,mBAAW,0BAHmD;AAI9DC,sBAAc,kBAJgD;AAK9DC,wBAAgBL,KAAKR,SAAL,CAAec;AAL+B,KAAX;AAAA,CAAjB,CAA/B;;AAQP;;;;;;;;;;;;;AAaO,IAAMC,gDAAoB,6BAAiB,UAACP,IAAD;AAAA,WAAW;AACzDC,wBAAgBD,KAAKR,SAAL,CAAeU,YAD0B;AAEzDnB,oBAAY,mBAF6C;AAGzDoB,mBAAW,qBAH8C;AAIzDC,sBAAc,aAJ2C;AAKzDC,wBAAgBL,KAAKR,SAAL,CAAegB;AAL0B,KAAX;AAAA,CAAjB,CAA1B;;AAiEPV,aAAaW,WAAb;AAAA,2EAA2B;AAAA,YAAiBC,KAAjB,SAAiBA,KAAjB;AAAA;AAAA;AAAA;AAAA;AAAA,8BACpBA,UAAU,OADU;AAAA;AAAA;AAAA;;AAAA,0DAEZ,KAAKlB,SAAL,CAAeG,iBAAf,CAAiCgB,QAAjC,CAA0Cd,UAA1C,CAAqDe,cAArD,GACH,KAAKpB,SAAL,CAAeC,KAAf,CAAqBkB,QAArB,CAA8Bd,UAA9B,CAAyCe,cAH1B;;AAAA;AAAA,8BAKjB,IAAIC,KAAJ,wCAA+CH,KAA/C,CALiB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAA3B;;AAAA;AAAA;AAAA;AAAA","file":"events.js","sourcesContent":["import _ from 'lodash'\nimport { wrapWeb3Function, normalizeWeb3Args, requireEventFromTXResult } from './utils'\n\n/**\n * Creates a categorical event.\n *\n * Note: this method is asynchronous and will return a Promise\n *\n * @function\n * @param {(Contract|string)} opts.collateralToken - The collateral token contract or its address\n * @param {(Contract|string)} opts.oracle - The oracle responsible for resolving this event\n * @param {(number|string|BigNumber)} opts.outcomeCount - The number of outcomes of this event\n * @returns {Contract} The created categorical event\n * @alias Gnosis#createCategoricalEvent\n */\nexport const createCategoricalEvent = wrapWeb3Function((self) => ({\n    callerContract: self.contracts.EventFactory,\n    methodName: 'createCategoricalEvent',\n    eventName: 'CategoricalEventCreation',\n    eventArgName: 'categoricalEvent',\n    resultContract: self.contracts.CategoricalEvent\n}))\n\n/**\n * Creates a scalar event.\n *\n * Note: this method is asynchronous and will return a Promise\n *\n * @function\n * @param {(Contract|string)} opts.collateralToken - The collateral token contract or its address\n * @param {(Contract|string)} opts.oracle - The oracle responsible for resolving this event\n * @param {(number|string|BigNumber)} opts.lowerBound - The lower bound for the event outcome\n * @param {(number|string|BigNumber)} opts.upperBound - The upper bound for the event outcome\n * @returns {Contract} The created scalar event\n * @alias Gnosis#createScalarEvent\n */\nexport const createScalarEvent = wrapWeb3Function((self) => ({\n    callerContract: self.contracts.EventFactory,\n    methodName: 'createScalarEvent',\n    eventName: 'ScalarEventCreation',\n    eventArgName: 'scalarEvent',\n    resultContract: self.contracts.ScalarEvent\n}))\n\n/**\n * Publishes an event description onto IPFS.\n *\n * Note: this method is asynchronous and will return a Promise\n *\n * @param {Object} eventDescription - A POD object describing the event\n * @param {string} eventDescription.title - A string describing the title of the event\n * @param {string} eventDescription.description - A string describing the purpose of the event\n * @param {string} eventDescription.resolutionDate - A string containing the resolution date of the event\n * @param {string[]} eventDescription.outcomes - A string array containing the outcomes of the event\n * @returns {string} The IPFS hash locating the published event\n * @alias Gnosis#publishEventDescription\n */\nexport async function publishEventDescription (description) {\n    return await this.ipfs.addJSONAsync(description)\n}\n\n/**\n * Loads an event description from IPFS.\n *\n * Note: this method is asynchronous and will return a Promise\n *\n * @param {string} ipfsHash - The IPFS hash locating the published event\n * @returns {Object} A POD object describing the event\n * @alias Gnosis#loadEventDescription\n */\nexport async function loadEventDescription (ipfsHash) {\n    return await this.ipfs.catJSONAsync(ipfsHash)\n}\n\n/**\n * Resolves an event. Assumes event is backed solely by a centralized oracle controlled by you\n *\n * Note: this method is asynchronous and will return a Promise\n *\n * @param {(Contract|string)} opts.event - The event address or instance\n * @param {(number|string|BigNumber)} opts.outcome - The outcome to set this event to. This is the zero-based index of the outcome for categorical events and the decimals-adjusted value of the outcome for scalar events.\n * @alias Gnosis#resolveEvent\n */\nexport async function resolveEvent() {\n    const [[eventAddress, outcome], opts] =\n        normalizeWeb3Args(Array.from(arguments), {\n            methodName: 'resolveEvent',\n            functionInputs: [\n                { name: 'event', type: 'address' },\n                { name: 'outcome', type: 'int256'},\n            ]\n        })\n\n    const txOpts = _.pick(opts, ['from', 'to', 'value', 'gas', 'gasPrice'])\n\n    const event = this.contracts.Event.at(eventAddress)\n    const oracle = this.contracts.CentralizedOracle.at(await event.oracle(txOpts))\n    requireEventFromTXResult(await oracle.setOutcome(outcome, txOpts), 'OutcomeAssignment')\n    requireEventFromTXResult(await event.setOutcome(txOpts), 'OutcomeAssignment')\n}\n\nresolveEvent.estimateGas = async function({ using }) {\n    if(using === 'stats') {\n        return this.contracts.CentralizedOracle.gasStats.setOutcome.averageGasUsed +\n            this.contracts.Event.gasStats.setOutcome.averageGasUsed\n    }\n    throw new Error(`unsupported gas estimation source ${using}`)\n}\n"]}