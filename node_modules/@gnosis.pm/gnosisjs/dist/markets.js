'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.sellOutcomeTokens = exports.buyOutcomeTokens = exports.createMarket = undefined;

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _from = require('babel-runtime/core-js/array/from');

var _from2 = _interopRequireDefault(_from);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

/**
 * Buys outcome tokens. If you have ether and plan on transacting with a market on an event which
 * uses EtherToken as collateral, be sure to convert the ether into EtherToken by sending ether to
 * the deposit() method of the contract. For other ERC20 collateral tokens, follow the token's
 * acquisition process defined by the token's contract.
 *
 * Note: this method is asynchronous and will return a Promise
 *
 * @param {(Contract|string)} opts.market - The market to buy tokens from
 * @param {(number|string|BigNumber)} opts.outcomeTokenIndex - The index of the outcome
 * @param {(number|string|BigNumber)} opts.outcomeTokenCount - Number of outcome tokens to buy
 * @param {(number|string|BigNumber)} [opts.approvalAmount] - Amount of collateral to allow market to spend. If unsupplied or null, allowance will be set to the cost of this transaction only if necessary. If set to 0, the approval transaction will be skipped.
 * @returns {BigNumber} How much collateral tokens caller paid
 * @alias Gnosis#buyOutcomeTokens
 */
var buyOutcomeTokens = exports.buyOutcomeTokens = function () {
    var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
        var _normalizeWeb3Args,
            _normalizeWeb3Args2,
            _normalizeWeb3Args2$,
            marketAddress,
            outcomeTokenIndex,
            outcomeTokenCount,
            opts,
            approvalAmount,
            market,
            collateralToken,
            baseCost,
            cost,
            buyer,
            marketAllowance,
            purchaseEvent,
            _args = arguments;

        return _regenerator2.default.wrap(function _callee$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        _normalizeWeb3Args = (0, _utils.normalizeWeb3Args)((0, _from2.default)(_args), {
                            methodName: 'buyOutcomeTokens',
                            functionInputs: [{ name: 'market', type: 'address' }, { name: 'outcomeTokenIndex', type: 'uint8' }, { name: 'outcomeTokenCount', type: 'uint256' }]
                        }), _normalizeWeb3Args2 = (0, _slicedToArray3.default)(_normalizeWeb3Args, 2), _normalizeWeb3Args2$ = (0, _slicedToArray3.default)(_normalizeWeb3Args2[0], 3), marketAddress = _normalizeWeb3Args2$[0], outcomeTokenIndex = _normalizeWeb3Args2$[1], outcomeTokenCount = _normalizeWeb3Args2$[2], opts = _normalizeWeb3Args2[1];
                        approvalAmount = opts && opts.approvalAmount;
                        market = this.contracts.Market.at(marketAddress);
                        _context.t0 = this.contracts.Token;
                        _context.t1 = this.contracts.Event;
                        _context.next = 7;
                        return market.eventContract();

                    case 7:
                        _context.t2 = _context.sent;
                        _context.next = 10;
                        return _context.t1.at.call(_context.t1, _context.t2).collateralToken();

                    case 10:
                        _context.t3 = _context.sent;
                        collateralToken = _context.t0.at.call(_context.t0, _context.t3);
                        _context.next = 14;
                        return this.lmsrMarketMaker.calcCost(marketAddress, outcomeTokenIndex, outcomeTokenCount);

                    case 14:
                        baseCost = _context.sent;
                        _context.t4 = baseCost;
                        _context.next = 18;
                        return market.calcMarketFee(baseCost);

                    case 18:
                        _context.t5 = _context.sent;
                        cost = _context.t4.add.call(_context.t4, _context.t5);

                        if (!(approvalAmount == null)) {
                            _context.next = 33;
                            break;
                        }

                        buyer = opts.from || this.defaultAccount;
                        _context.next = 24;
                        return collateralToken.allowance(buyer, marketAddress);

                    case 24:
                        marketAllowance = _context.sent;

                        if (!marketAllowance.lt(cost)) {
                            _context.next = 31;
                            break;
                        }

                        _context.t6 = _utils.requireEventFromTXResult;
                        _context.next = 29;
                        return collateralToken.approve(marketAddress, cost);

                    case 29:
                        _context.t7 = _context.sent;
                        (0, _context.t6)(_context.t7, 'Approval');

                    case 31:
                        _context.next = 39;
                        break;

                    case 33:
                        if (!this.web3.toBigNumber(0).lt(approvalAmount)) {
                            _context.next = 39;
                            break;
                        }

                        _context.t8 = _utils.requireEventFromTXResult;
                        _context.next = 37;
                        return collateralToken.approve(marketAddress, approvalAmount);

                    case 37:
                        _context.t9 = _context.sent;
                        (0, _context.t8)(_context.t9, 'Approval');

                    case 39:
                        _context.t10 = _utils.requireEventFromTXResult;
                        _context.next = 42;
                        return market.buy(outcomeTokenIndex, outcomeTokenCount, cost);

                    case 42:
                        _context.t11 = _context.sent;
                        purchaseEvent = (0, _context.t10)(_context.t11, 'OutcomeTokenPurchase');
                        return _context.abrupt('return', purchaseEvent.args.outcomeTokenCost.plus(purchaseEvent.args.marketFees));

                    case 45:
                    case 'end':
                        return _context.stop();
                }
            }
        }, _callee, this);
    }));

    return function buyOutcomeTokens() {
        return _ref.apply(this, arguments);
    };
}();

/**
 * Sells outcome tokens. If transacting with a market which deals with EtherToken as collateral,
 * will need additional step of sending a withdraw(uint amount) transaction to the EtherToken
 * contract if raw ether is desired.
 *
 * Note: this method is asynchronous and will return a Promise
 *
 * @param {(Contract|string)} opts.market - The market to sell tokens to
 * @param {(number|string|BigNumber)} opts.outcomeTokenIndex - The index of the outcome
 * @param {(number|string|BigNumber)} opts.outcomeTokenCount - Number of outcome tokens to sell
 * @param {(number|string|BigNumber)} [opts.approvalAmount] - Amount of outcome tokens to allow market to handle. If unsupplied or null, allowance will be set to the sale amount only if necessary. If set to 0, the approval transaction will be skipped.
 * @returns {BigNumber} How much collateral tokens caller received from sale
 * @alias Gnosis#sellOutcomeTokens
 */
var sellOutcomeTokens = exports.sellOutcomeTokens = function () {
    var _ref4 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3() {
        var _normalizeWeb3Args3,
            _normalizeWeb3Args4,
            _normalizeWeb3Args4$,
            marketAddress,
            outcomeTokenIndex,
            outcomeTokenCount,
            opts,
            approvalAmount,
            market,
            outcomeToken,
            baseProfit,
            minProfit,
            seller,
            marketAllowance,
            saleEvent,
            _args3 = arguments;

        return _regenerator2.default.wrap(function _callee3$(_context3) {
            while (1) {
                switch (_context3.prev = _context3.next) {
                    case 0:
                        _normalizeWeb3Args3 = (0, _utils.normalizeWeb3Args)((0, _from2.default)(_args3), {
                            methodName: 'sellOutcomeTokens',
                            functionInputs: [{ name: 'market', type: 'address' }, { name: 'outcomeTokenIndex', type: 'uint8' }, { name: 'outcomeTokenCount', type: 'uint256' }]
                        }), _normalizeWeb3Args4 = (0, _slicedToArray3.default)(_normalizeWeb3Args3, 2), _normalizeWeb3Args4$ = (0, _slicedToArray3.default)(_normalizeWeb3Args4[0], 3), marketAddress = _normalizeWeb3Args4$[0], outcomeTokenIndex = _normalizeWeb3Args4$[1], outcomeTokenCount = _normalizeWeb3Args4$[2], opts = _normalizeWeb3Args4[1];
                        approvalAmount = opts && opts.approvalAmount;
                        market = this.contracts.Market.at(marketAddress);
                        _context3.t0 = this.contracts.Token;
                        _context3.t1 = this.contracts.Event;
                        _context3.next = 7;
                        return market.eventContract();

                    case 7:
                        _context3.t2 = _context3.sent;
                        _context3.t3 = outcomeTokenIndex;
                        _context3.next = 11;
                        return _context3.t1.at.call(_context3.t1, _context3.t2).outcomeTokens(_context3.t3);

                    case 11:
                        _context3.t4 = _context3.sent;
                        outcomeToken = _context3.t0.at.call(_context3.t0, _context3.t4);
                        _context3.next = 15;
                        return this.lmsrMarketMaker.calcProfit(marketAddress, outcomeTokenIndex, outcomeTokenCount);

                    case 15:
                        baseProfit = _context3.sent;
                        _context3.t5 = baseProfit;
                        _context3.next = 19;
                        return market.calcMarketFee(baseProfit);

                    case 19:
                        _context3.t6 = _context3.sent;
                        minProfit = _context3.t5.sub.call(_context3.t5, _context3.t6);

                        if (!(approvalAmount == null)) {
                            _context3.next = 34;
                            break;
                        }

                        seller = opts.from || this.defaultAccount;
                        _context3.next = 25;
                        return outcomeToken.allowance(seller, marketAddress);

                    case 25:
                        marketAllowance = _context3.sent;

                        if (!marketAllowance.lt(outcomeTokenCount)) {
                            _context3.next = 32;
                            break;
                        }

                        _context3.t7 = _utils.requireEventFromTXResult;
                        _context3.next = 30;
                        return outcomeToken.approve(marketAddress, outcomeTokenCount);

                    case 30:
                        _context3.t8 = _context3.sent;
                        (0, _context3.t7)(_context3.t8, 'Approval');

                    case 32:
                        _context3.next = 40;
                        break;

                    case 34:
                        if (!this.web3.toBigNumber(0).lt(approvalAmount)) {
                            _context3.next = 40;
                            break;
                        }

                        _context3.t9 = _utils.requireEventFromTXResult;
                        _context3.next = 38;
                        return outcomeToken.approve(marketAddress, approvalAmount);

                    case 38:
                        _context3.t10 = _context3.sent;
                        (0, _context3.t9)(_context3.t10, 'Approval');

                    case 40:
                        _context3.t11 = _utils.requireEventFromTXResult;
                        _context3.next = 43;
                        return market.sell(outcomeTokenIndex, outcomeTokenCount, minProfit);

                    case 43:
                        _context3.t12 = _context3.sent;
                        saleEvent = (0, _context3.t11)(_context3.t12, 'OutcomeTokenSale');
                        return _context3.abrupt('return', saleEvent.args.outcomeTokenProfit.minus(saleEvent.args.marketFees));

                    case 46:
                    case 'end':
                        return _context3.stop();
                }
            }
        }, _callee3, this);
    }));

    return function sellOutcomeTokens() {
        return _ref4.apply(this, arguments);
    };
}();

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Creates a market.
 *
 * Note: this method is asynchronous and will return a Promise
 *
 * @function
 * @param {(Contract|string)} opts.event - The forwarded oracle contract or its address
 * @param {(Contract|string)} opts.marketMaker - The collateral token contract or its address
 * @param {(number|string|BigNumber)} opts.fee - The fee factor. Specifying 1,000,000 corresponds to 100%, 50,000 corresponds to 5%, etc.
 * @param {(Contract|string)} [opts.marketFactory={@link Gnosis#standardMarketFactory}] - The factory contract
 * @returns {Contract} The created market contract instance. If marketFactory is [StandardMarketFactory](https://gnosis.github.io/gnosis-contracts/docs/StandardMarketFactory/), this should be a [StandardMarket](https://gnosis.github.io/gnosis-contracts/docs/StandardMarket/)
 * @alias Gnosis#createMarket
 */
var createMarket = exports.createMarket = (0, _utils.wrapWeb3Function)(function (self, opts) {
    return {
        callerContract: opts.marketFactory || self.standardMarketFactory,
        callerABI: self.contracts.StandardMarketFactory.abi,
        methodName: 'createMarket',
        eventName: 'StandardMarketCreation',
        eventArgName: 'market',
        resultContract: self.contracts.Market,
        argAliases: {
            event: 'eventContract'
        }
    };
});

buyOutcomeTokens.estimateGas = function () {
    var _ref3 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2(_ref2) {
        var using = _ref2.using;
        return _regenerator2.default.wrap(function _callee2$(_context2) {
            while (1) {
                switch (_context2.prev = _context2.next) {
                    case 0:
                        if (!(using === 'stats')) {
                            _context2.next = 2;
                            break;
                        }

                        return _context2.abrupt('return', this.contracts.Token.gasStats.approve.averageGasUsed + this.contracts.Market.gasStats.buy.averageGasUsed);

                    case 2:
                        throw new Error('unsupported gas estimation source ' + using);

                    case 3:
                    case 'end':
                        return _context2.stop();
                }
            }
        }, _callee2, this);
    }));

    return function (_x) {
        return _ref3.apply(this, arguments);
    };
}();

sellOutcomeTokens.estimateGas = function () {
    var _ref6 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4(_ref5) {
        var using = _ref5.using;
        return _regenerator2.default.wrap(function _callee4$(_context4) {
            while (1) {
                switch (_context4.prev = _context4.next) {
                    case 0:
                        if (!(using === 'stats')) {
                            _context4.next = 2;
                            break;
                        }

                        return _context4.abrupt('return', this.contracts.Token.gasStats.approve.averageGasUsed + this.contracts.Market.gasStats.sell.averageGasUsed);

                    case 2:
                        throw new Error('unsupported gas estimation source ' + using);

                    case 3:
                    case 'end':
                        return _context4.stop();
                }
            }
        }, _callee4, this);
    }));

    return function (_x2) {
        return _ref6.apply(this, arguments);
    };
}();
//# sourceMappingURL=markets.js.map